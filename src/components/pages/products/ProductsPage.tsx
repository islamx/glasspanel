"use client";
import React, { useState, useEffect } from 'react';
import { useTranslations } from 'next-intl';
import pb from '@/lib/pb';
import DataList from '@/components/shared/DataList/DataList';
import ProductImage from './ProductImage/ProductImage';
import Modal from '@/components/shared/Modal';
import AddProductForm from './AddProductForm';
import Button from '@/components/shared/form/Button';
import { ProductFormData } from './AddProductForm/validation';
import styles from '@/styles/common.module.scss';

interface Product {
  id: string;
  name_en: string;
  name_ar: string;
  description_en: string;
  description_ar: string;
  price: number;
  category: string;
  category_en: string;
  category_ar: string;
  image?: string;
  created: string;
}

interface ProductsPageProps {
  locale: string;
}

const ProductsPage: React.FC<ProductsPageProps> = ({ locale }) => {
  const t = useTranslations('products');
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [showAddModal, setShowAddModal] = useState(false);
  const [submitting, setSubmitting] = useState(false);

  useEffect(() => {
    let isMounted = true;
    const abortController = new AbortController();

    const fetchProducts = async () => {
      try {
        setLoading(true);
        
        const records = await pb.collection('products').getList(1, 50, {
          sort: '-created'
        });
        
        if (isMounted) {
          setProducts(records.items as unknown as Product[]);
        }
      } catch (error: any) {
        if (isMounted && error.name !== 'AbortError') {
          setProducts([]);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };

    fetchProducts();

    return () => {
      isMounted = false;
      abortController.abort();
    };
  }, []);

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    
    // Format date in both Arabic and English with Gregorian calendar
    const options: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      calendar: 'gregory' // This ensures Gregorian calendar
    };
    
    if (locale === 'ar') {
      // Arabic format
      return date.toLocaleDateString('ar-SA', options);
    } else {
      // English format
      return date.toLocaleDateString('en-US', options);
    }
  };

  const getLocalizedCategory = (product: Product) => {
    if (locale === 'ar') {
      return product.category_ar || product.category || '';
    }
    return product.category_en || product.category || '';
  };

  const getLocalizedValue = (product: Product, field: 'name' | 'description') => {
    const fieldName = `${field}_${locale}`;
    return product[fieldName as keyof Product] as string || '';
  };

  const renderImage = (product: Product) => {
    return (
      <ProductImage
        imageUrl={product.image}
        productName={getLocalizedValue(product, 'name')}
        productId={product.id}
        baseUrl={pb.baseUrl}
      />
    );
  };

  const handleAddProduct = async (values: ProductFormData) => {
    try {
      setSubmitting(true);
      
      // Create data object for PocketBase - simplified version
      const productData: any = {
        name_en: values.name_en,
        name_ar: values.name_ar,
        description_en: values.description_en,
        description_ar: values.description_ar,
        price: Number(values.price),
        category_en: values.category_en,
        category_ar: values.category_ar
      };
      
      // Always use FormData for consistency
      const formData = new FormData();
      formData.append('name_en', values.name_en);
      formData.append('name_ar', values.name_ar);
      formData.append('description_en', values.description_en);
      formData.append('description_ar', values.description_ar);
      formData.append('price', values.price.toString());
      formData.append('category_en', values.category_en); // English category value
      formData.append('category_ar', values.category_ar); // Arabic category value
      // Note: id field is auto-generated by PocketBase, so we don't include it
      
      if (values.image && values.image instanceof File) {
        formData.append('image', values.image);
                        // FormData with image
              } else {
                // FormData without image
              }
      
      
      
      try {
        const record = await pb.collection('products').create(formData);
                          // Show success message
                  alert('Product created successfully!');
        
        // Refresh the products list
        const updatedProducts = await pb.collection('products').getList(1, 50, {
          sort: '-created'
        });
        setProducts(updatedProducts.items as unknown as Product[]);
        
        // Close modal
        setShowAddModal(false);
                      } catch (createError: any) {
                  // Show error message to user
                  alert(`Error creating product: ${createError.message}`);
                  throw createError;
                }
                  } catch (error: any) {
                // Handle error silently
              } finally {
      setSubmitting(false);
    }
  };

  const handleCancelAdd = () => {
    setShowAddModal(false);
  };

  const columns = [
    { 
      key: 'image', 
      label: t('image'),
      render: (value: any, product: Product) => renderImage(product)
    },
    { 
      key: 'name', 
      label: t('name'),
      render: (value: any, product: Product) => getLocalizedValue(product, 'name')
    },
    { 
      key: 'category', 
      label: t('category'),
      render: (value: any, product: Product) => getLocalizedCategory(product)
    },
    { 
      key: 'price', 
      label: t('price'),
      render: (value: number) => `$${(value || 0).toFixed(2)}`
    },
    { 
      key: 'description', 
      label: t('description'),
      render: (value: any, product: Product) => getLocalizedValue(product, 'description')
    },
    { 
      key: 'created', 
      label: t('created'),
      render: (value: string) => value ? formatDate(value) : ''
    }
  ];

  return (
    <>
      <div className="d-flex justify-content-between align-items-center mb-4">
        <h1 className={styles.title}>{t('title')}</h1>
        <Button
          onClick={() => setShowAddModal(true)}
          className={`btn-primary px-4 py-2 ${styles.glassmorphismBtn}`}
        >
          <i className="bi bi-plus-circle me-2"></i>
          {t('addProduct')}
        </Button>
      </div>

      <DataList
        data={products} // Pass all products
        columns={columns}
        searchTerm={searchTerm}
        onSearchChange={setSearchTerm}
        searchPlaceholder={t('searchPlaceholder')}
        itemsPerPage={5}
        loading={loading}
        previousText={t('previous')}
        nextText={t('next')}
        showingText={t('showing')}
        ofText={t('of')}
        itemName={t('products')}
        noDataTitle={t('noData.title')}
        noDataDescription={t('noData.description')}
        noSearchResultsTitle={t('noSearchResults.title')}
        noSearchResultsDescription={t('noSearchResults.description')}
      />

      <Modal
        show={showAddModal}
        onHide={handleCancelAdd}
        title={t('addProduct')}
        size="lg"
        actions={
          <>
            <Button
              type="button"
              onClick={handleCancelAdd}
              className={`me-2 ${styles.modalCancelBtn}`}
            >
              {t('cancel')}
            </Button>
            <Button
              type="submit"
              loading={submitting}
              className={`btn-primary ${styles.modalSubmitBtn}`}
              onClick={() => {
                // Trigger form submission
                const form = document.querySelector('form');
                if (form) {
                  form.dispatchEvent(new Event('submit', { bubbles: true }));
                }
              }}
            >
              {t('addProduct')}
            </Button>
          </>
        }
      >
        <AddProductForm
          onSubmit={handleAddProduct}
          onCancel={handleCancelAdd}
          loading={submitting}
          locale={locale}
        />
      </Modal>
    </>
  );
};

export default ProductsPage; 